<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.11.1</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deferred.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferred Shading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a></li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a></li>
<li class="level1"><a href="#lighting">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a></li>
<li class="level1"><a href="#realprojects">Integration in real projects</a></li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2>Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2>Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// temporary textures</span></div><div class="line">        texture mrt_output target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> chain_scope</div><div class="line">        </div><div class="line">        target mrt_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line">            </div><div class="line">            shadows off</div><div class="line">            material_scheme GBuffer</div><div class="line">            </div><div class="line">            <span class="comment">// everything but the lights and their meshes</span></div><div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//These values are synchronized with the code</span></div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue  79   </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2>Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2>Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3>Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3>Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div><div class="line">         float4 iPosition : POSITION,</div><div class="line">         float3 iNormal   : NORMAL,</div><div class="line">         float2 iUV0 : TEXCOORD0,</div><div class="line"></div><div class="line">         out float4 oPosition : POSITION,</div><div class="line">         out float3 oViewPos : TEXCOORD0,</div><div class="line">         out float3 oNormal : TEXCOORD1,</div><div class="line">         out float2 oUV0 : TEXCOORD2,</div><div class="line"></div><div class="line">         uniform float4x4 cWorldViewProj,</div><div class="line">         uniform float4x4 cWorldView</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div><div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div><div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div><div class="line">         oUV0 = iUV0;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div><div class="line">         float3 iViewPos : TEXCOORD0,</div><div class="line">         float3 iNormal   : TEXCOORD1,</div><div class="line">         float3 iTangent : TEXCOORD2,</div><div class="line">         float3 iBiNormal : TEXCOORD3,</div><div class="line">         float2 iUV0 : TEXCOORD4,</div><div class="line"></div><div class="line">         out float4 oColor0 : COLOR0,</div><div class="line">         out float4 oColor1 : COLOR1,</div><div class="line"></div><div class="line">         uniform sampler sNormalMap : <span class="keyword">register</span>(s0),</div><div class="line">         uniform sampler sTex0 : <span class="keyword">register</span>(s1),</div><div class="line">         uniform float4 cDiffuseColour,</div><div class="line">         uniform <span class="keywordtype">float</span> cFarDistance,</div><div class="line">         uniform <span class="keywordtype">float</span> cSpecularity</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div><div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div><div class="line">         oColor0.a = cSpecularity;</div><div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div><div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div><div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div><div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div><div class="line"> }</div></div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3>Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3>Postponing transparent objects</h3>
<p>We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.</p>
<p>To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.</p>
<h3>Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div><div class="line">        <span class="keyword">const</span> Renderable* rend)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161">Ogre::MaterialManager::getSingleton</a>();</div><div class="line">    <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> curSchemeName = matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#ad03ea02e140fc1e7312d14626e59d45d">getActiveScheme</a>();</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MaterialManager::DEFAULT_SCHEME_NAME);</div><div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div><div class="line"></div><div class="line">    Technique* gBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    gBufferTech-&gt;removeAllPasses();</div><div class="line">    gBufferTech-&gt;setSchemeName(schemeName);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div><div class="line">    rtShaderGen.createShaderBasedTechnique(*originalMaterial, originalTechnique-&gt;getSchemeName(), <span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    Technique* noGBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    noGBufferTech-&gt;removeAllPasses();</div><div class="line">    noGBufferTech-&gt;setSchemeName(<span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div><div class="line">    {</div><div class="line">        Pass* originalPass = originalTechnique-&gt;getPass(i);</div><div class="line">        PassProperties props = inspectPass(originalPass, lodIndex, rend);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!props.isDeferred)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">            rtShaderGen.validateMaterial(<span class="stringliteral">&quot;NoGBuffer&quot;</span>, originalMaterial-&gt;getName(), originalMaterial-&gt;getGroup());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">            <span class="comment">//Just copy the technique so it gets rendered regularly</span></div><div class="line">            Pass* clonePass = noGBufferTech-&gt;createPass();</div><div class="line">            *clonePass = *originalPass;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Pass* newPass = gBufferTech-&gt;createPass();</div><div class="line">        MaterialGenerator::Perm perm = getPermutation(props);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::MaterialPtr</a>&amp; templateMat = mMaterialGenerator.getMaterial(perm);</div><div class="line">        </div><div class="line">        <span class="comment">//We assume that the GBuffer technique contains only one pass. But its true.</span></div><div class="line">        *newPass = *(templateMat-&gt;<a class="code" href="class_ogre_1_1_material.html#a011abd64ab54e84c516068caa5001c91">getTechnique</a>(0)-&gt;<a class="code" href="class_ogre_1_1_technique.html#ab0014ffd501b4e1bef5eaae0340e71a7">getPass</a>(0));</div><div class="line">        fillPass(newPass, originalPass, props);    </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> gBufferTech;</div><div class="line">}</div></div><!-- fragment --> <h2>Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2>Seeing it in action</h2>
<p>Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :</p>
<div class="image">
<img src="GBufferPerfHUD.PNG" alt="GBufferPerfHUD.PNG"/>
</div>
<p>Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="lighting"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div><div class="line">{</div><div class="line"></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div><div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div><div class="line">        </div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div><div class="line">            shadows off</div><div class="line">            </div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">                </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                first_render_queue 1</div><div class="line">                last_render_queue  9            </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the lights and their meshes</span></div><div class="line">            pass render_custom DeferredLight</div><div class="line">            {</div><div class="line">                input 0 mrt_output 0</div><div class="line">                input 1 mrt_output 1</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the objects that skipped rendering into the gbuffer</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                material_scheme NoGBuffer</div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue 79</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the post-GBuffer render queue objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//This value is synchronized with the code</span></div><div class="line">                first_render_queue 80</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h3>Why do we need four target passes ?</h3>
<p>This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.</p>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3>Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3>Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3>Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3>Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div><div class="line"></div><div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div><div class="line">    Technique* tech = mAmbientLight-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a2a54dff8ade9ab6838c1517062f0eb98">getMaterial</a>()-&gt;<a class="code" href="class_ogre_1_1_material.html#a37ae7259ce89bdc38828ea1b977bdbcf">getBestTechnique</a>();</div><div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div><div class="line">    <span class="keywordflow">for</span> (LightList::const_iterator it = lightList.begin(); it != lightList.end(); it++) </div><div class="line">    {</div><div class="line">        Light* light = *it;</div><div class="line">        <a class="code" href="class_ogre_1_1_hashed_vector.html">Ogre::LightList</a> ll;</div><div class="line">        ll.<a class="code" href="class_ogre_1_1_hashed_vector.html#a87bfcde773502ee964a677580724188f">push_back</a>(light);</div><div class="line"></div><div class="line">        <span class="comment">//if (++i != 2) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div><div class="line"></div><div class="line">        LightsMap::iterator dLightIt = mLights.find(light);</div><div class="line">        DLight* dLight = 0;</div><div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end()) </div><div class="line">        {</div><div class="line">            dLight = createDLight(light);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            dLight = dLightIt-&gt;second;</div><div class="line">            dLight-&gt;updateFromParent();</div><div class="line">        }</div><div class="line">        dLight-&gt;updateFromCamera(cam);</div><div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div><div class="line"></div><div class="line">        <span class="comment">//Update shadow texture</span></div><div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div><div class="line">        {</div><div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div><div class="line"></div><div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div><div class="line">            sm-&gt;_resumeRendering(context);</div><div class="line">            </div><div class="line">            Pass* pass = tech-&gt;getPass(0);</div><div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div><div class="line">            assert(tus);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; shadowTex = sm-&gt;getShadowTexture(0);</div><div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div><div class="line">            {</div><div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Seeing it in action</h3>
<p>Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :</p>
<div class="image">
<img src="DeferredCone1.PNG" alt="DeferredCone1.PNG"/>
</div>
<p>Here is a visualization of the texture being built :</p>
<div class="image">
<img src="DeferredCone2.PNG" alt="DeferredCone2.PNG"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2>Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        compositor_logic SSAOLogic</div><div class="line">        </div><div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div><div class="line">        texture scene target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca">PF_R8G8B8A8</a></div><div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurX target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurY target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line"></div><div class="line">        <span class="comment">// the scene we want to modulate</span></div><div class="line">        target scene</div><div class="line">        {</div><div class="line">            input previous</div><div class="line">        }</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        target ssao</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// our SSAO listener number</span></div><div class="line">                identifier 42</div><div class="line"></div><div class="line">                material ssao</div><div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div><div class="line">                input 0 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurX</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurX</div><div class="line">                input 0 ssao</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurY</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurY</div><div class="line">                input 0 ssaoBlurX</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div><div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div><div class="line">                material modulate</div><div class="line">                input 0 scene</div><div class="line">                input 1 ssaoBlurY</div><div class="line">                <span class="comment">//input 1 ssao</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques. ...">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2>Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And thats it! In the demo, the DeferredShading class takes care of that.</p>
<h2>Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2>Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implemeting it in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="http://www.gamedev.net/page/reference/index.html/_//feature/fprogramming/deferred-rendering-demystified-r2746">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
